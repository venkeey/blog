<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photo to Line Drawing Converter</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .image-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 20px;
        }
        .image-box {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas {
            max-width: 100%;
            border: 1px solid #ddd;
        }
        .controls {
            margin: 20px 0;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 5px;
        }
        .control-group {
            margin-bottom: 10px;
        }
        label {
            display: inline-block;
            width: 150px;
        }
        button {
            padding: 8px 16px;
            background: #4285f4;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
        }
        button:hover {
            background: #3367d6;
        }
        .file-info {
            margin-top: 5px;
            font-size: 0.9em;
            color: #555;
        }
        #dropArea {
            border: 2px dashed #ccc;
            border-radius: 5px;
            padding: 25px;
            text-align: center;
            background: #f9f9f9;
            cursor: pointer;
        }
        #dropArea.highlight {
            border-color: #4285f4;
            background: #e8f0fe;
        }
        .preset-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }
        .preset-btn {
            background: #e0e0e0;
            color: #333;
            border: 1px solid #ccc;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
        }
        .preset-btn:hover {
            background: #d0d0d0;
        }
        .preset-btn.active {
            background: #4285f4;
            color: white;
            border-color: #3367d6;
        }
        .tabs {
            display: flex;
            margin-bottom: 15px;
            border-bottom: 1px solid #ddd;
        }
        .tab {
            padding: 8px 15px;
            cursor: pointer;
            background: #f0f0f0;
            border: 1px solid #ddd;
            border-bottom: none;
            margin-right: 5px;
            border-radius: 5px 5px 0 0;
        }
        .tab.active {
            background: #fff;
            border-bottom: 1px solid #fff;
            margin-bottom: -1px;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
    </style>
</head>
<body>
    <h1>Photo to Line Drawing Converter</h1>
    <p>Convert passport photos or headshots to line drawings with minimal file size while preserving recognizable features.</p>
    
    <div class="container">
        <div id="dropArea">
            <p>Drag & drop your photo here or click to select a file</p>
            <input type="file" id="fileInput" accept="image/*" style="display: none;">
        </div>
        
        <div class="controls">
            <h3>Adjustment Controls</h3>
            
            <div class="preset-buttons">
                <button class="preset-btn" id="presetRecognizable">Recognizable Face</button>
                <button class="preset-btn" id="presetMinimalSize">Minimal File Size</button>
                <button class="preset-btn" id="presetDetailedSketch">Detailed Sketch</button>
                <button class="preset-btn" id="presetSimpleOutline">Simple Outline</button>
            </div>
            
            <div class="tabs">
                <div class="tab active" data-tab="basic">Basic</div>
                <div class="tab" data-tab="advanced">Advanced</div>
                <div class="tab" data-tab="output">Output</div>
            </div>
            
            <div class="tab-content active" id="basic-tab">
                <div class="control-group">
                    <label for="detailLevel">Detail Level:</label>
                    <input type="range" id="detailLevel" min="1" max="10" value="7">
                    <span id="detailLevelValue">7</span>
                </div>
                <div class="control-group">
                    <label for="lineThickness">Line Thickness:</label>
                    <input type="range" id="lineThickness" min="1" max="5" value="1">
                    <span id="lineThicknessValue">1</span>
                </div>
                <div class="control-group">
                    <label for="facialFeatures">Facial Features:</label>
                    <select id="facialFeatures">
                        <option value="all" selected>All Features</option>
                        <option value="prominent">Prominent Only</option>
                        <option value="minimal">Minimal (Outline)</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="stylePreset">Drawing Style:</label>
                    <select id="stylePreset">
                        <option value="sketch" selected>Sketch</option>
                        <option value="contour">Contour Lines</option>
                        <option value="cartoon">Cartoon</option>
                        <option value="minimal">Minimal</option>
                    </select>
                </div>
            </div>
            
            <div class="tab-content" id="advanced-tab">
                <div class="control-group">
                    <label for="edgeThreshold">Edge Sensitivity:</label>
                    <input type="range" id="edgeThreshold" min="10" max="100" value="30">
                    <span id="edgeThresholdValue">30</span>
                </div>
                <div class="control-group">
                    <label for="blurAmount">Blur Amount:</label>
                    <input type="range" id="blurAmount" min="1" max="10" value="3">
                    <span id="blurAmountValue">3</span>
                </div>
                <div class="control-group">
                    <label for="edgeMethod">Edge Detection:</label>
                    <select id="edgeMethod">
                        <option value="sobel">Sobel (Standard)</option>
                        <option value="canny" selected>Canny (Enhanced)</option>
                        <option value="laplacian">Laplacian (Detailed)</option>
                        <option value="facial">Facial Feature Priority</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="lineSmoothing">Line Smoothing:</label>
                    <input type="range" id="lineSmoothing" min="0" max="5" value="1">
                    <span id="lineSmoothingValue">1</span>
                </div>
                <div class="control-group">
                    <label for="contrastEnhance">Contrast Enhance:</label>
                    <input type="range" id="contrastEnhance" min="0" max="100" value="20">
                    <span id="contrastEnhanceValue">20</span>
                </div>
                <div class="control-group">
                    <label for="preserveFeatures">Preserve Features:</label>
                    <input type="checkbox" id="preserveFeatures" checked>
                </div>
                <div class="control-group">
                    <label for="invertColors">Invert Colors:</label>
                    <input type="checkbox" id="invertColors">
                </div>
            </div>
            
            <div class="tab-content" id="output-tab">
                <div class="control-group">
                    <label for="outputSize">Output Size:</label>
                    <select id="outputSize">
                        <option value="original">Original Size</option>
                        <option value="300">300px (width)</option>
                        <option value="200" selected>200px (width)</option>
                        <option value="150">150px (width)</option>
                        <option value="100">100px (width)</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="outputQuality">JPEG Quality:</label>
                    <input type="range" id="outputQuality" min="0" max="100" value="80">
                    <span id="outputQualityValue">80%</span>
                </div>
                <div class="control-group">
                    <label for="outputFormat">Format:</label>
                    <select id="outputFormat">
                        <option value="jpeg" selected>JPEG</option>
                        <option value="png">PNG</option>
                    </select>
                </div>
            </div>
            
            <div class="control-group">
                <button id="processBtn" disabled>Process Image</button>
                <button id="downloadBtn" disabled>Download Result</button>
            </div>
        </div>
        
        <div class="image-container">
            <div class="image-box">
                <h3>Original Image</h3>
                <canvas id="originalCanvas"></canvas>
                <div id="originalInfo" class="file-info"></div>
            </div>
            <div class="image-box">
                <h3>Line Drawing Result</h3>
                <canvas id="resultCanvas"></canvas>
                <div id="resultInfo" class="file-info"></div>
            </div>
        </div>
    </div>

    <script>
        // DOM elements
        const dropArea = document.getElementById('dropArea');
        const fileInput = document.getElementById('fileInput');
        const originalCanvas = document.getElementById('originalCanvas');
        const resultCanvas = document.getElementById('resultCanvas');
        const originalInfo = document.getElementById('originalInfo');
        const resultInfo = document.getElementById('resultInfo');
        const processBtn = document.getElementById('processBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        
        // Tab navigation
        const tabs = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');
        
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                // Remove active class from all tabs and contents
                tabs.forEach(t => t.classList.remove('active'));
                tabContents.forEach(c => c.classList.remove('active'));
                
                // Add active class to clicked tab and corresponding content
                tab.classList.add('active');
                document.getElementById(`${tab.dataset.tab}-tab`).classList.add('active');
            });
        });
        
        // Preset buttons
        const presetRecognizable = document.getElementById('presetRecognizable');
        const presetMinimalSize = document.getElementById('presetMinimalSize');
        const presetDetailedSketch = document.getElementById('presetDetailedSketch');
        const presetSimpleOutline = document.getElementById('presetSimpleOutline');
        
        // Control elements - Basic
        const detailLevel = document.getElementById('detailLevel');
        const lineThickness = document.getElementById('lineThickness');
        const facialFeatures = document.getElementById('facialFeatures');
        const stylePreset = document.getElementById('stylePreset');
        
        // Control elements - Advanced
        const edgeThreshold = document.getElementById('edgeThreshold');
        const blurAmount = document.getElementById('blurAmount');
        const edgeMethod = document.getElementById('edgeMethod');
        const lineSmoothing = document.getElementById('lineSmoothing');
        const contrastEnhance = document.getElementById('contrastEnhance');
        const preserveFeatures = document.getElementById('preserveFeatures');
        const invertColors = document.getElementById('invertColors');
        
        // Control elements - Output
        const outputSize = document.getElementById('outputSize');
        const outputQuality = document.getElementById('outputQuality');
        const outputFormat = document.getElementById('outputFormat');
        
        // Value display elements
        const detailLevelValue = document.getElementById('detailLevelValue');
        const lineThicknessValue = document.getElementById('lineThicknessValue');
        const edgeThresholdValue = document.getElementById('edgeThresholdValue');
        const blurAmountValue = document.getElementById('blurAmountValue');
        const lineSmoothingValue = document.getElementById('lineSmoothingValue');
        const contrastEnhanceValue = document.getElementById('contrastEnhanceValue');
        const outputQualityValue = document.getElementById('outputQualityValue');
        
        // Original image data
        let originalImage = null;
        
        // Preset configurations
        presetRecognizable.addEventListener('click', () => {
            // Set values for maximum recognizability
            detailLevel.value = 8;
            detailLevelValue.textContent = 8;
            lineThickness.value = 1;
            lineThicknessValue.textContent = 1;
            facialFeatures.value = 'all';
            stylePreset.value = 'sketch';
            
            edgeThreshold.value = 20;
            edgeThresholdValue.textContent = 20;
            blurAmount.value = 2;
            blurAmountValue.textContent = 2;
            edgeMethod.value = 'facial';
            lineSmoothing.value = 1;
            lineSmoothingValue.textContent = 1;
            contrastEnhance.value = 30;
            contrastEnhanceValue.textContent = 30;
            preserveFeatures.checked = true;
            invertColors.checked = false;
            
            outputSize.value = '200';
            outputQuality.value = 80;
            outputQualityValue.textContent = '80%';
            outputFormat.value = 'jpeg';
            
            highlightPresetButton(presetRecognizable);
        });
        
        presetMinimalSize.addEventListener('click', () => {
            // Set values for minimal file size
            detailLevel.value = 3;
            detailLevelValue.textContent = 3;
            lineThickness.value = 1;
            lineThicknessValue.textContent = 1;
            facialFeatures.value = 'prominent';
            stylePreset.value = 'minimal';
            
            edgeThreshold.value = 40;
            edgeThresholdValue.textContent = 40;
            blurAmount.value = 5;
            blurAmountValue.textContent = 5;
            edgeMethod.value = 'sobel';
            lineSmoothing.value = 3;
            lineSmoothingValue.textContent = 3;
            contrastEnhance.value = 50;
            contrastEnhanceValue.textContent = 50;
            preserveFeatures.checked = true;
            invertColors.checked = false;
            
            outputSize.value = '100';
            outputQuality.value = 50;
            outputQualityValue.textContent = '50%';
            outputFormat.value = 'jpeg';
            
            highlightPresetButton(presetMinimalSize);
        });
        
        presetDetailedSketch.addEventListener('click', () => {
            // Set values for detailed sketch
            detailLevel.value = 10;
            detailLevelValue.textContent = 10;
            lineThickness.value = 1;
            lineThicknessValue.textContent = 1;
            facialFeatures.value = 'all';
            stylePreset.value = 'sketch';
            
            edgeThreshold.value = 15;
            edgeThresholdValue.textContent = 15;
            blurAmount.value = 1;
            blurAmountValue.textContent = 1;
            edgeMethod.value = 'laplacian';
            lineSmoothing.value = 0;
            lineSmoothingValue.textContent = 0;
            contrastEnhance.value = 40;
            contrastEnhanceValue.textContent = 40;
            preserveFeatures.checked = true;
            invertColors.checked = false;
            
            outputSize.value = '300';
            outputQuality.value = 90;
            outputQualityValue.textContent = '90%';
            outputFormat.value = 'jpeg';
            
            highlightPresetButton(presetDetailedSketch);
        });
        
        presetSimpleOutline.addEventListener('click', () => {
            // Set values for simple outline
            detailLevel.value = 2;
            detailLevelValue.textContent = 2;
            lineThickness.value = 2;
            lineThicknessValue.textContent = 2;
            facialFeatures.value = 'minimal';
            stylePreset.value = 'contour';
            
            edgeThreshold.value = 50;
            edgeThresholdValue.textContent = 50;
            blurAmount.value = 8;
            blurAmountValue.textContent = 8;
            edgeMethod.value = 'sobel';
            lineSmoothing.value = 5;
            lineSmoothingValue.textContent = 5;
            contrastEnhance.value = 70;
            contrastEnhanceValue.textContent = 70;
            preserveFeatures.checked = false;
            invertColors.checked = false;
            
            outputSize.value = '150';
            outputQuality.value = 60;
            outputQualityValue.textContent = '60%';
            outputFormat.value = 'jpeg';
            
            highlightPresetButton(presetSimpleOutline);
        });
        
        function highlightPresetButton(activeButton) {
            // Remove active class from all preset buttons
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Add active class to the clicked button
            activeButton.classList.add('active');
        }
        
        // Update value displays
        detailLevel.addEventListener('input', () => {
            detailLevelValue.textContent = detailLevel.value;
        });
        
        lineThickness.addEventListener('input', () => {
            lineThicknessValue.textContent = lineThickness.value;
        });
        
        edgeThreshold.addEventListener('input', () => {
            edgeThresholdValue.textContent = edgeThreshold.value;
        });
        
        blurAmount.addEventListener('input', () => {
            blurAmountValue.textContent = blurAmount.value;
        });
        
        lineSmoothing.addEventListener('input', () => {
            lineSmoothingValue.textContent = lineSmoothing.value;
        });
        
        contrastEnhance.addEventListener('input', () => {
            contrastEnhanceValue.textContent = contrastEnhance.value;
        });
        
        outputQuality.addEventListener('input', () => {
            outputQualityValue.textContent = `${outputQuality.value}%`;
        });
        
        // File drop handling
        function setupFileDrop() {
            // Prevent default behaviors for all drag events
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropArea.addEventListener(eventName, function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log(eventName + ' event handled');
                }, false);
            });
            
            // Highlight drop area when item is dragged over it
            ['dragenter', 'dragover'].forEach(eventName => {
                dropArea.addEventListener(eventName, function() {
                    dropArea.classList.add('highlight');
                    console.log('Highlight added');
                }, false);
            });
            
            // Remove highlight when item is dragged away or dropped
            ['dragleave', 'drop'].forEach(eventName => {
                dropArea.addEventListener(eventName, function() {
                    dropArea.classList.remove('highlight');
                    console.log('Highlight removed');
                }, false);
            });
            
            // Handle dropped files
            dropArea.addEventListener('drop', function(e) {
                console.log('File dropped');
                const dt = e.dataTransfer;
                const files = dt.files;
                if (files.length) {
                    handleFiles(files);
                }
            }, false);
            
            // Handle click to select files
            dropArea.addEventListener('click', function() {
                fileInput.click();
            }, false);
            
            // Handle selected files
            fileInput.addEventListener('change', function(e) {
                const files = e.target.files;
                if (files.length) {
                    handleFiles(files);
                }
            }, false);
            
            console.log('File drop handlers set up');
        }
        
        // Initialize file drop handling
        setupFileDrop();
        
        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            if (files.length) {
                handleFiles(files);
            }
        }
        
        function handleFileSelect(e) {
            const files = e.target.files;
            if (files.length) {
                handleFiles(files);
            }
        }
        
        function handleFiles(files) {
            const file = files[0];
            if (!file.type.match('image.*')) {
                alert('Please select an image file.');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                loadImage(e.target.result, file.name, file.size);
            };
            reader.readAsDataURL(file);
        }
        
        function loadImage(src, fileName, fileSize) {
            originalImage = new Image();
            originalImage.onload = function() {
                // Draw original image
                const ctx = originalCanvas.getContext('2d');
                originalCanvas.width = originalImage.width;
                originalCanvas.height = originalImage.height;
                ctx.drawImage(originalImage, 0, 0);
                
                // Display original file info
                originalInfo.textContent = `${fileName} - ${formatFileSize(fileSize)}`;
                
                // Enable process button
                processBtn.disabled = false;
                
                // Process image automatically
                processImage();
            };
            originalImage.src = src;
            console.log('Loading image:', fileName);
        }
        
        // Process image when button is clicked
        processBtn.addEventListener('click', processImage);
        
        function processImage() {
            if (!originalImage) return;
            
            // Get parameter values from both basic and advanced tabs
            const detail = parseInt(detailLevel.value);
            const thickness = parseInt(lineThickness.value);
            const features = facialFeatures.value;
            const style = stylePreset.value;
            
            const threshold = parseInt(edgeThreshold.value);
            const blur = parseInt(blurAmount.value);
            const method = edgeMethod.value;
            const smoothing = parseInt(lineSmoothing.value);
            const contrast = parseInt(contrastEnhance.value);
            const preserve = preserveFeatures.checked;
            const invert = invertColors.checked;
            
            const size = outputSize.value;
            const quality = parseInt(outputQuality.value) / 100;
            const format = outputFormat.value;
            
            // Calculate dimensions
            let width, height;
            if (size === 'original') {
                width = originalImage.width;
                height = originalImage.height;
            } else {
                const maxWidth = parseInt(size);
                const aspectRatio = originalImage.height / originalImage.width;
                width = maxWidth;
                height = Math.round(maxWidth * aspectRatio);
            }
            
            // Set canvas dimensions
            resultCanvas.width = width;
            resultCanvas.height = height;
            
            // Get canvas context
            const ctx = resultCanvas.getContext('2d');
            
            // Draw and resize original image
            ctx.drawImage(originalImage, 0, 0, width, height);
            
            // Get image data
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            // Create a copy of original data for facial feature detection
            const originalData = new Uint8ClampedArray(data);
            
            // First pass: convert to grayscale
            for (let i = 0; i < data.length; i += 4) {
                const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                data[i] = data[i + 1] = data[i + 2] = avg;
            }
            
            // Apply contrast enhancement based on detail level and contrast setting
            const effectiveContrast = Math.max(contrast, detail * 5);
            if (effectiveContrast > 0) {
                enhanceContrast(data, effectiveContrast);
            }
            
            // Apply blur based on detail level and blur setting
            const effectiveBlur = style === 'minimal' ? Math.max(blur, 11 - detail) : blur;
            if (effectiveBlur > 1) {
                const blurredData = applyBoxBlur(data, width, height, effectiveBlur);
                for (let i = 0; i < data.length; i++) {
                    data[i] = blurredData[i];
                }
            }
            
            // Detect facial features if needed
            let faceRegions = null;
            if (preserve || method === 'facial') {
                faceRegions = detectFacialRegions(originalData, width, height);
            }
            
            // Apply edge detection based on selected method and style
            let edgeData;
            const effectiveThreshold = style === 'contour' ? threshold * 1.5 : threshold;
            
            switch (method) {
                case 'facial':
                    edgeData = applyFacialFeatureEdgeDetection(data, width, height, effectiveThreshold, faceRegions, features);
                    break;
                case 'canny':
                    edgeData = applyCannyEdgeDetection(data, width, height, effectiveThreshold);
                    break;
                case 'laplacian':
                    edgeData = applyLaplacianEdgeDetection(data, width, height, effectiveThreshold);
                    break;
                case 'sobel':
                default:
                    edgeData = applySobelEdgeDetection(data, width, height, effectiveThreshold);
                    break;
            }
            
            // Apply style-specific processing
            let processedData = edgeData;
            
            if (style === 'cartoon') {
                processedData = applyCartoonEffect(processedData, width, height);
            } else if (style === 'contour') {
                processedData = applyContourEffect(processedData, width, height);
            }
            
            // Apply line thickness
            if (thickness > 1) {
                processedData = applyLineThickness(processedData, width, height, thickness);
            }
            
            // Apply line smoothing based on style and smoothing setting
            const effectiveSmoothing = style === 'minimal' ? Math.max(smoothing, 3) : smoothing;
            if (effectiveSmoothing > 0) {
                processedData = smoothLines(processedData, width, height, effectiveSmoothing);
            }
            
            // Preserve important facial features if enabled
            if (preserve && faceRegions) {
                processedData = enhanceFacialFeatures(processedData, originalData, width, height, faceRegions, features);
            }
            
            // Apply inversion if needed
            if (invert) {
                for (let i = 0; i < processedData.length; i += 4) {
                    processedData[i] = 255 - processedData[i];
                    processedData[i + 1] = 255 - processedData[i + 1];
                    processedData[i + 2] = 255 - processedData[i + 2];
                }
            }
            
            // Put processed data back to canvas
            for (let i = 0; i < data.length; i++) {
                data[i] = processedData[i];
            }
            
            ctx.putImageData(imageData, 0, 0);
            
            // Calculate and display result file size
            const quality = parseInt(outputQuality.value) / 100;
            const resultDataUrl = resultCanvas.toDataURL('image/jpeg', quality);
            const fileSizeInBytes = estimateJpegSize(resultDataUrl);
            resultInfo.textContent = `Estimated size: ${formatFileSize(fileSizeInBytes)}`;
            
            // Enable download button
            downloadBtn.disabled = false;
        }
        
        // Apply box blur
        function applyBoxBlur(data, width, height, radius) {
            const result = new Uint8ClampedArray(data.length);
            const size = width * height * 4;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let r = 0, g = 0, b = 0, a = 0, count = 0;
                    
                    // Sample the surrounding pixels
                    for (let ky = -radius; ky <= radius; ky++) {
                        for (let kx = -radius; kx <= radius; kx++) {
                            const px = x + kx;
                            const py = y + ky;
                            
                            if (px >= 0 && px < width && py >= 0 && py < height) {
                                const i = (py * width + px) * 4;
                                r += data[i];
                                g += data[i + 1];
                                b += data[i + 2];
                                a += data[i + 3];
                                count++;
                            }
                        }
                    }
                    
                    // Calculate average
                    const i = (y * width + x) * 4;
                    result[i] = r / count;
                    result[i + 1] = g / count;
                    result[i + 2] = b / count;
                    result[i + 3] = a / count;
                }
            }
            
            return result;
        }
        
        // Detect facial regions (eyes, nose, mouth, etc.)
        function detectFacialRegions(data, width, height) {
            // This is a simplified facial feature detection
            // In a real implementation, you would use a proper face detection library
            
            // For now, we'll use a heuristic approach to estimate facial features
            // based on image intensity and gradients
            
            const regions = {
                eyes: [],
                nose: null,
                mouth: null,
                face: null
            };
            
            // First, try to detect the face region (assuming it's centered)
            const centerX = Math.floor(width / 2);
            const centerY = Math.floor(height / 2);
            
            // Estimate face width and height (typically 2/3 of the image for passport photos)
            const faceWidth = Math.floor(width * 0.7);
            const faceHeight = Math.floor(height * 0.8);
            
            regions.face = {
                x: centerX - Math.floor(faceWidth / 2),
                y: Math.floor(height * 0.15), // Face typically starts near the top
                width: faceWidth,
                height: faceHeight
            };
            
            // Estimate eye positions (in upper third of face)
            const eyeY = regions.face.y + Math.floor(regions.face.height * 0.25);
            const eyeWidth = Math.floor(regions.face.width * 0.2);
            const eyeHeight = Math.floor(regions.face.height * 0.1);
            const eyeGap = Math.floor(regions.face.width * 0.2);
            
            regions.eyes.push({
                x: centerX - Math.floor(eyeGap / 2) - eyeWidth,
                y: eyeY,
                width: eyeWidth,
                height: eyeHeight
            });
            
            regions.eyes.push({
                x: centerX + Math.floor(eyeGap / 2),
                y: eyeY,
                width: eyeWidth,
                height: eyeHeight
            });
            
            // Estimate nose position (center of face)
            regions.nose = {
                x: centerX - Math.floor(regions.face.width * 0.1),
                y: regions.face.y + Math.floor(regions.face.height * 0.4),
                width: Math.floor(regions.face.width * 0.2),
                height: Math.floor(regions.face.height * 0.2)
            };
            
            // Estimate mouth position (lower third of face)
            regions.mouth = {
                x: centerX - Math.floor(regions.face.width * 0.25),
                y: regions.face.y + Math.floor(regions.face.height * 0.7),
                width: Math.floor(regions.face.width * 0.5),
                height: Math.floor(regions.face.height * 0.1)
            };
            
            // Refine regions based on image intensity
            refineRegionsByIntensity(regions, data, width, height);
            
            return regions;
        }
        
        // Refine facial regions based on image intensity
        function refineRegionsByIntensity(regions, data, width, height) {
            // This function would analyze the image data to better locate features
            // For simplicity, we'll just use the estimated regions
            return regions;
        }
        
        // Apply facial feature-based edge detection
        function applyFacialFeatureEdgeDetection(data, width, height, threshold, faceRegions, featureLevel) {
            const result = new Uint8ClampedArray(data.length);
            
            // Initialize result with white background
            for (let i = 0; i < result.length; i++) {
                result[i] = 255;
            }
            
            // Define feature importance based on level
            const featureImportance = {
                eyes: featureLevel === 'minimal' ? 1.5 : 2.5,
                eyebrows: featureLevel === 'minimal' ? 1.2 : 2.0,
                nose: featureLevel === 'minimal' ? 0.8 : 1.5,
                mouth: featureLevel === 'minimal' ? 1.2 : 2.0,
                face: featureLevel === 'minimal' ? 1.5 : 1.0,
                other: featureLevel === 'minimal' ? 0.3 : 1.0
            };
            
            // Apply edge detection with varying thresholds based on region
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    // Determine which facial region this pixel belongs to
                    let regionType = 'other';
                    let importance = featureImportance.other;
                    
                    if (faceRegions) {
                        // Check eyes
                        for (const eye of faceRegions.eyes) {
                            if (x >= eye.x && x < eye.x + eye.width && 
                                y >= eye.y && y < eye.y + eye.height) {
                                regionType = 'eyes';
                                importance = featureImportance.eyes;
                                break;
                            }
                            // Check area above eyes (eyebrows)
                            if (x >= eye.x && x < eye.x + eye.width && 
                                y >= eye.y - eye.height/2 && y < eye.y) {
                                regionType = 'eyebrows';
                                importance = featureImportance.eyebrows;
                                break;
                            }
                        }
                        
                        // Check nose
                        if (regionType === 'other' && faceRegions.nose &&
                            x >= faceRegions.nose.x && x < faceRegions.nose.x + faceRegions.nose.width && 
                            y >= faceRegions.nose.y && y < faceRegions.nose.y + faceRegions.nose.height) {
                            regionType = 'nose';
                            importance = featureImportance.nose;
                        }
                        
                        // Check mouth
                        if (regionType === 'other' && faceRegions.mouth &&
                            x >= faceRegions.mouth.x && x < faceRegions.mouth.x + faceRegions.mouth.width && 
                            y >= faceRegions.mouth.y && y < faceRegions.mouth.y + faceRegions.mouth.height) {
                            regionType = 'mouth';
                            importance = featureImportance.mouth;
                        }
                        
                        // Check face outline
                        if (regionType === 'other' && faceRegions.face) {
                            const face = faceRegions.face;
                            const borderWidth = Math.max(2, Math.floor(face.width * 0.03));
                            
                            if ((x >= face.x && x < face.x + face.width && 
                                ((y >= face.y && y < face.y + borderWidth) || 
                                 (y >= face.y + face.height - borderWidth && y < face.y + face.height))) ||
                                (y >= face.y && y < face.y + face.height && 
                                ((x >= face.x && x < face.x + borderWidth) || 
                                 (x >= face.x + face.width - borderWidth && x < face.x + face.width)))) {
                                regionType = 'face';
                                importance = featureImportance.face;
                            }
                        }
                    }
                    
                    // Apply edge detection with adjusted threshold based on region importance
                    const adjustedThreshold = threshold / importance;
                    
                    // Get pixel values in a 3x3 grid
                    const i = (y * width + x) * 4;
                    
                    // Top row
                    const tl = data[((y - 1) * width + (x - 1)) * 4];
                    const t = data[((y - 1) * width + x) * 4];
                    const tr = data[((y - 1) * width + (x + 1)) * 4];
                    
                    // Middle row
                    const l = data[(y * width + (x - 1)) * 4];
                    const c = data[(y * width + x) * 4];
                    const r = data[(y * width + (x + 1)) * 4];
                    
                    // Bottom row
                    const bl = data[((y + 1) * width + (x - 1)) * 4];
                    const b = data[((y + 1) * width + x) * 4];
                    const br = data[((y + 1) * width + (x + 1)) * 4];
                    
                    // Sobel X gradient
                    const gx = -tl - 2 * l - bl + tr + 2 * r + br;
                    
                    // Sobel Y gradient
                    const gy = -tl - 2 * t - tr + bl + 2 * b + br;
                    
                    // Gradient magnitude
                    const g = Math.sqrt(gx * gx + gy * gy);
                    
                    // Apply threshold
                    if (g > adjustedThreshold) {
                        result[i] = result[i + 1] = result[i + 2] = 0; // Black edge
                    }
                    
                    // For eyes and mouth, enhance the edges
                    if ((regionType === 'eyes' || regionType === 'mouth') && g > adjustedThreshold * 0.7) {
                        result[i] = result[i + 1] = result[i + 2] = 0;
                    }
                }
            }
            
            return result;
        }
        
        // Enhance facial features in the processed image
        function enhanceFacialFeatures(processedData, originalData, width, height, faceRegions, featureLevel) {
            const result = new Uint8ClampedArray(processedData.length);
            
            // Copy processed data
            for (let i = 0; i < processedData.length; i++) {
                result[i] = processedData[i];
            }
            
            // Define regions to enhance based on feature level
            const enhanceEyes = featureLevel !== 'minimal';
            const enhanceNose = featureLevel === 'all';
            const enhanceMouth = featureLevel !== 'minimal';
            const enhanceFace = true;
            
            // Enhance eyes
            if (enhanceEyes && faceRegions.eyes) {
                for (const eye of faceRegions.eyes) {
                    enhanceRegion(result, width, eye, 1.5);
                    
                    // Add pupil if not already present
                    const pupilX = eye.x + Math.floor(eye.width / 2);
                    const pupilY = eye.y + Math.floor(eye.height / 2);
                    const pupilRadius = Math.max(1, Math.floor(eye.width / 8));
                    
                    drawCircle(result, width, pupilX, pupilY, pupilRadius);
                }
            }
            
            // Enhance nose
            if (enhanceNose && faceRegions.nose) {
                // Draw nose outline
                const nose = faceRegions.nose;
                const noseX = nose.x + Math.floor(nose.width / 2);
                
                // Draw a simplified nose shape
                const noseTop = nose.y;
                const noseBottom = nose.y + nose.height;
                const noseWidth = Math.floor(nose.width * 0.6);
                
                // Draw nose bridge
                drawLine(result, width, noseX, noseTop, noseX, noseBottom - Math.floor(nose.height / 3));
                
                // Draw nostrils
                drawLine(result, width, noseX - Math.floor(noseWidth / 2), noseBottom, noseX, noseBottom - Math.floor(nose.height / 4));
                drawLine(result, width, noseX + Math.floor(noseWidth / 2), noseBottom, noseX, noseBottom - Math.floor(nose.height / 4));
            }
            
            // Enhance mouth
            if (enhanceMouth && faceRegions.mouth) {
                const mouth = faceRegions.mouth;
                const mouthCenterX = mouth.x + Math.floor(mouth.width / 2);
                const mouthCenterY = mouth.y + Math.floor(mouth.height / 2);
                const mouthWidth = mouth.width;
                const mouthHeight = mouth.height;
                
                // Draw mouth outline
                drawLine(result, width, mouth.x, mouthCenterY, mouth.x + mouthWidth, mouthCenterY);
                
                // Add a slight curve to the mouth
                const curveHeight = Math.floor(mouthHeight / 4);
                for (let x = 0; x < mouthWidth; x++) {
                    const relX = x / mouthWidth - 0.5; // -0.5 to 0.5
                    const y = Math.floor(curveHeight * (1 - 4 * relX * relX)); // Parabola
                    
                    const px = mouth.x + x;
                    const py = mouthCenterY + y;
                    
                    if (px >= 0 && px < width && py >= 0 && py < height) {
                        const i = (py * width + px) * 4;
                        result[i] = result[i + 1] = result[i + 2] = 0;
                    }
                }
            }
            
            // Enhance face outline
            if (enhanceFace && faceRegions.face) {
                const face = faceRegions.face;
                
                // Draw face outline with a smoother curve
                const faceLeft = face.x;
                const faceRight = face.x + face.width;
                const faceTop = face.y;
                const faceBottom = face.y + face.height;
                const faceWidth = face.width;
                const faceHeight = face.height;
                
                // Draw chin with a curve
                const chinWidth = Math.floor(faceWidth * 0.7);
                const chinLeft = faceLeft + Math.floor((faceWidth - chinWidth) / 2);
                const chinRight = chinLeft + chinWidth;
                
                for (let x = chinLeft; x <= chinRight; x++) {
                    const relX = (x - chinLeft) / chinWidth - 0.5; // -0.5 to 0.5
                    const y = Math.floor(faceHeight * 0.1 * (4 * relX * relX)); // Parabola
                    
                    const px = x;
                    const py = faceBottom - y;
                    
                    if (px >= 0 && px < width && py >= 0 && py < height) {
                        const i = (py * width + px) * 4;
                        result[i] = result[i + 1] = result[i + 2] = 0;
                    }
                }
                
                // Draw sides of face
                drawLine(result, width, faceLeft, faceTop + Math.floor(faceHeight * 0.3), chinLeft, faceBottom);
                drawLine(result, width, faceRight, faceTop + Math.floor(faceHeight * 0.3), chinRight, faceBottom);
            }
            
            return result;
        }
        
        // Helper function to enhance a specific region
        function enhanceRegion(data, width, region, intensity) {
            const x = region.x;
            const y = region.y;
            const w = region.width;
            const h = region.height;
            
            // Draw a rectangle around the region
            for (let i = 0; i < w; i++) {
                const px = x + i;
                
                if (px >= 0 && px < width) {
                    // Top edge
                    if (y >= 0) {
                        const topIdx = (y * width + px) * 4;
                        data[topIdx] = data[topIdx + 1] = data[topIdx + 2] = 0;
                    }
                    
                    // Bottom edge
                    const bottomY = y + h - 1;
                    if (bottomY >= 0) {
                        const bottomIdx = (bottomY * width + px) * 4;
                        data[bottomIdx] = data[bottomIdx + 1] = data[bottomIdx + 2] = 0;
                    }
                }
            }
            
            for (let j = 0; j < h; j++) {
                const py = y + j;
                
                // Left edge
                if (x >= 0 && py >= 0) {
                    const leftIdx = (py * width + x) * 4;
                    data[leftIdx] = data[leftIdx + 1] = data[leftIdx + 2] = 0;
                }
                
                // Right edge
                const rightX = x + w - 1;
                if (rightX >= 0 && py >= 0) {
                    const rightIdx = (py * width + rightX) * 4;
                    data[rightIdx] = data[rightIdx + 1] = data[rightIdx + 2] = 0;
                }
            }
        }
        
        // Helper function to draw a circle
        function drawCircle(data, width, centerX, centerY, radius) {
            for (let y = centerY - radius; y <= centerY + radius; y++) {
                for (let x = centerX - radius; x <= centerX + radius; x++) {
                    const distance = Math.sqrt((x - centerX) * (x - centerX) + (y - centerY) * (y - centerY));
                    
                    if (distance <= radius) {
                        const i = (y * width + x) * 4;
                        data[i] = data[i + 1] = data[i + 2] = 0;
                    }
                }
            }
        }
        
        // Helper function to draw a line
        function drawLine(data, width, x1, y1, x2, y2) {
            // Bresenham's line algorithm
            const dx = Math.abs(x2 - x1);
            const dy = Math.abs(y2 - y1);
            const sx = x1 < x2 ? 1 : -1;
            const sy = y1 < y2 ? 1 : -1;
            let err = dx - dy;
            
            while (true) {
                if (x1 >= 0 && x1 < width && y1 >= 0) {
                    const i = (y1 * width + x1) * 4;
                    data[i] = data[i + 1] = data[i + 2] = 0;
                }
                
                if (x1 === x2 && y1 === y2) break;
                
                const e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    x1 += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    y1 += sy;
                }
            }
        }
        
        // Apply cartoon effect
        function applyCartoonEffect(data, width, height) {
            const result = new Uint8ClampedArray(data.length);
            
            // Copy original data
            for (let i = 0; i < data.length; i++) {
                result[i] = data[i];
            }
            
            // Thicken lines
            const thickened = applyLineThickness(data, width, height, 2);
            
            // Simplify areas between lines
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    
                    // If not an edge
                    if (thickened[i] === 255) {
                        // Find nearest edge
                        let minDist = 999999;
                        let nearestEdgeValue = 255;
                        
                        for (let sy = Math.max(0, y - 10); sy < Math.min(height, y + 10); sy++) {
                            for (let sx = Math.max(0, x - 10); sx < Math.min(width, x + 10); sx++) {
                                const si = (sy * width + sx) * 4;
                                
                                if (thickened[si] === 0) {
                                    const dist = Math.sqrt((x - sx) * (x - sx) + (y - sy) * (y - sy));
                                    if (dist < minDist) {
                                        minDist = dist;
                                    }
                                }
                            }
                        }
                        
                        // Make areas more uniform based on distance to edge
                        if (minDist < 5) {
                            result[i] = result[i + 1] = result[i + 2] = 240;
                        } else {
                            result[i] = result[i + 1] = result[i + 2] = 255;
                        }
                    } else {
                        result[i] = result[i + 1] = result[i + 2] = 0;
                    }
                }
            }
            
            return result;
        }
        
        // Apply contour effect
        function applyContourEffect(data, width, height) {
            const result = new Uint8ClampedArray(data.length);
            
            // Copy original data
            for (let i = 0; i < data.length; i++) {
                result[i] = data[i];
            }
            
            // Simplify by removing some edges
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const i = (y * width + x) * 4;
                    
                    // If this is an edge
                    if (data[i] === 0) {
                        // Count neighboring edges
                        let edgeCount = 0;
                        
                        for (let ky = -1; ky <= 1; ky++) {
                            for (let kx = -1; kx <= 1; kx++) {
                                if (kx === 0 && ky === 0) continue;
                                
                                const ni = ((y + ky) * width + (x + kx)) * 4;
                                if (data[ni] === 0) {
                                    edgeCount++;
                                }
                            }
                        }
                        
                        // Remove isolated edges
                        if (edgeCount < 2) {
                            result[i] = result[i + 1] = result[i + 2] = 255;
                        }
                    }
                }
            }
            
            return result;
        }
        
        // Enhance contrast
        function enhanceContrast(data, amount) {
            // Find min and max values
            let min = 255;
            let max = 0;
            
            for (let i = 0; i < data.length; i += 4) {
                if (data[i] < min) min = data[i];
                if (data[i] > max) max = data[i];
            }
            
            // Calculate contrast factor
            const factor = (259 * (amount + 255)) / (255 * (259 - amount));
            
            // Apply contrast enhancement
            for (let i = 0; i < data.length; i += 4) {
                const val = factor * (data[i] - 128) + 128;
                data[i] = data[i + 1] = data[i + 2] = Math.max(0, Math.min(255, val));
            }
        }
        
        // Apply Sobel edge detection
        function applySobelEdgeDetection(data, width, height, threshold) {
            const result = new Uint8ClampedArray(data.length);
            
            // Initialize result with white background
            for (let i = 0; i < result.length; i++) {
                result[i] = 255;
            }
            
            // Apply Sobel operator
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    // Get pixel values in a 3x3 grid
                    const i = (y * width + x) * 4;
                    
                    // Top row
                    const tl = data[((y - 1) * width + (x - 1)) * 4];
                    const t = data[((y - 1) * width + x) * 4];
                    const tr = data[((y - 1) * width + (x + 1)) * 4];
                    
                    // Middle row
                    const l = data[(y * width + (x - 1)) * 4];
                    const r = data[(y * width + (x + 1)) * 4];
                    
                    // Bottom row
                    const bl = data[((y + 1) * width + (x - 1)) * 4];
                    const b = data[((y + 1) * width + x) * 4];
                    const br = data[((y + 1) * width + (x + 1)) * 4];
                    
                    // Sobel X gradient
                    const gx = -tl - 2 * l - bl + tr + 2 * r + br;
                    
                    // Sobel Y gradient
                    const gy = -tl - 2 * t - tr + bl + 2 * b + br;
                    
                    // Gradient magnitude
                    const g = Math.sqrt(gx * gx + gy * gy);
                    
                    // Apply threshold
                    if (g > threshold) {
                        result[i] = result[i + 1] = result[i + 2] = 0; // Black edge
                    }
                }
            }
            
            return result;
        }
        
        // Apply Canny edge detection (enhanced edge detection)
        function applyCannyEdgeDetection(data, width, height, threshold) {
            const result = new Uint8ClampedArray(data.length);
            const gradientMagnitude = new Array(width * height);
            const gradientDirection = new Array(width * height);
            
            // Initialize result with white background
            for (let i = 0; i < result.length; i++) {
                result[i] = 255;
            }
            
            // Step 1: Calculate gradient magnitude and direction
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = y * width + x;
                    
                    // Top row
                    const tl = data[((y - 1) * width + (x - 1)) * 4];
                    const t = data[((y - 1) * width + x) * 4];
                    const tr = data[((y - 1) * width + (x + 1)) * 4];
                    
                    // Middle row
                    const l = data[(y * width + (x - 1)) * 4];
                    const r = data[(y * width + (x + 1)) * 4];
                    
                    // Bottom row
                    const bl = data[((y + 1) * width + (x - 1)) * 4];
                    const b = data[((y + 1) * width + x) * 4];
                    const br = data[((y + 1) * width + (x + 1)) * 4];
                    
                    // Sobel X gradient
                    const gx = -tl - 2 * l - bl + tr + 2 * r + br;
                    
                    // Sobel Y gradient
                    const gy = -tl - 2 * t - tr + bl + 2 * b + br;
                    
                    // Gradient magnitude
                    gradientMagnitude[idx] = Math.sqrt(gx * gx + gy * gy);
                    
                    // Gradient direction (in radians)
                    gradientDirection[idx] = Math.atan2(gy, gx);
                }
            }
            
            // Step 2: Non-maximum suppression
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = y * width + x;
                    const i = idx * 4;
                    
                    // Get gradient direction in degrees and convert to one of four directions (0, 45, 90, 135)
                    let direction = gradientDirection[idx] * 180 / Math.PI;
                    if (direction < 0) direction += 180;
                    
                    let neighbor1, neighbor2;
                    
                    // Round to nearest 45 degrees
                    if ((direction >= 0 && direction < 22.5) || (direction >= 157.5 && direction <= 180)) {
                        // 0 degrees - horizontal
                        neighbor1 = gradientMagnitude[idx - 1];
                        neighbor2 = gradientMagnitude[idx + 1];
                    } else if (direction >= 22.5 && direction < 67.5) {
                        // 45 degrees - diagonal
                        neighbor1 = gradientMagnitude[(y - 1) * width + (x + 1)];
                        neighbor2 = gradientMagnitude[(y + 1) * width + (x - 1)];
                    } else if (direction >= 67.5 && direction < 112.5) {
                        // 90 degrees - vertical
                        neighbor1 = gradientMagnitude[(y - 1) * width + x];
                        neighbor2 = gradientMagnitude[(y + 1) * width + x];
                    } else {
                        // 135 degrees - diagonal
                        neighbor1 = gradientMagnitude[(y - 1) * width + (x - 1)];
                        neighbor2 = gradientMagnitude[(y + 1) * width + (x + 1)];
                    }
                    
                    // If current pixel is not a local maximum, suppress it
                    if (gradientMagnitude[idx] < neighbor1 || gradientMagnitude[idx] < neighbor2) {
                        gradientMagnitude[idx] = 0;
                    }
                }
            }
            
            // Step 3: Hysteresis thresholding
            const lowThreshold = threshold * 0.5;
            const highThreshold = threshold;
            
            // First pass: mark strong edges
            const strongEdges = new Set();
            const weakEdges = new Map();
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = y * width + x;
                    const magnitude = gradientMagnitude[idx];
                    
                    if (magnitude >= highThreshold) {
                        // Strong edge
                        strongEdges.add(idx);
                        const i = idx * 4;
                        result[i] = result[i + 1] = result[i + 2] = 0; // Black edge
                    } else if (magnitude >= lowThreshold) {
                        // Weak edge
                        weakEdges.set(idx, {x, y});
                    }
                }
            }
            
            // Second pass: trace weak edges connected to strong edges
            const dx = [-1, 0, 1, -1, 1, -1, 0, 1];
            const dy = [-1, -1, -1, 0, 0, 1, 1, 1];
            
            for (const idx of strongEdges) {
                const x = idx % width;
                const y = Math.floor(idx / width);
                
                // Check 8 neighbors
                for (let d = 0; d < 8; d++) {
                    const nx = x + dx[d];
                    const ny = y + dy[d];
                    
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                        const neighborIdx = ny * width + nx;
                        if (weakEdges.has(neighborIdx)) {
                            // Convert weak edge to strong edge
                            strongEdges.add(neighborIdx);
                            const i = neighborIdx * 4;
                            result[i] = result[i + 1] = result[i + 2] = 0; // Black edge
                            weakEdges.delete(neighborIdx);
                        }
                    }
                }
            }
            
            return result;
        }
        
        // Apply Laplacian edge detection (detailed edge detection)
        function applyLaplacianEdgeDetection(data, width, height, threshold) {
            const result = new Uint8ClampedArray(data.length);
            
            // Initialize result with white background
            for (let i = 0; i < result.length; i++) {
                result[i] = 255;
            }
            
            // Laplacian kernel
            const kernel = [
                0, 1, 0,
                1, -4, 1,
                0, 1, 0
            ];
            
            // Apply Laplacian operator
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const i = (y * width + x) * 4;
                    let sum = 0;
                    
                    // Apply kernel
                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const px = x + kx;
                            const py = y + ky;
                            const ki = (ky + 1) * 3 + (kx + 1);
                            
                            if (px >= 0 && px < width && py >= 0 && py < height) {
                                const pi = (py * width + px) * 4;
                                sum += data[pi] * kernel[ki];
                            }
                        }
                    }
                    
                    // Apply threshold to detect edges
                    if (Math.abs(sum) > threshold) {
                        result[i] = result[i + 1] = result[i + 2] = 0; // Black edge
                    }
                }
            }
            
            return result;
        }
        
        // Apply line thickness
        function applyLineThickness(data, width, height, thickness) {
            const result = new Uint8ClampedArray(data.length);
            
            // Copy original data
            for (let i = 0; i < data.length; i++) {
                result[i] = data[i];
            }
            
            // For each black pixel, make surrounding pixels black too
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    
                    // If this is an edge pixel (black)
                    if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0) {
                        // Make surrounding pixels black too
                        for (let ky = -thickness + 1; ky < thickness; ky++) {
                            for (let kx = -thickness + 1; kx < thickness; kx++) {
                                const px = x + kx;
                                const py = y + ky;
                                
                                if (px >= 0 && px < width && py >= 0 && py < height) {
                                    const ni = (py * width + px) * 4;
                                    result[ni] = result[ni + 1] = result[ni + 2] = 0;
                                }
                            }
                        }
                    }
                }
            }
            
            return result;
        }
        
        // Smooth lines to reduce jaggedness
        function smoothLines(data, width, height, smoothingLevel) {
            if (smoothingLevel <= 0) return data;
            
            const result = new Uint8ClampedArray(data.length);
            
            // Copy original data
            for (let i = 0; i < data.length; i++) {
                result[i] = data[i];
            }
            
            // Apply multiple passes of smoothing
            for (let pass = 0; pass < smoothingLevel; pass++) {
                const tempData = new Uint8ClampedArray(data.length);
                
                // Copy current data to temp buffer
                for (let i = 0; i < data.length; i++) {
                    tempData[i] = result[i];
                }
                
                // Apply smoothing
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const i = (y * width + x) * 4;
                        
                        // Only process edge pixels (black)
                        if (tempData[i] === 0 && tempData[i + 1] === 0 && tempData[i + 2] === 0) {
                            // Count black neighbors
                            let blackNeighbors = 0;
                            let totalNeighbors = 0;
                            
                            for (let ky = -1; ky <= 1; ky++) {
                                for (let kx = -1; kx <= 1; kx++) {
                                    if (kx === 0 && ky === 0) continue; // Skip center pixel
                                    
                                    const px = x + kx;
                                    const py = y + ky;
                                    
                                    if (px >= 0 && px < width && py >= 0 && py < height) {
                                        const ni = (py * width + px) * 4;
                                        totalNeighbors++;
                                        
                                        if (tempData[ni] === 0 && tempData[ni + 1] === 0 && tempData[ni + 2] === 0) {
                                            blackNeighbors++;
                                        }
                                    }
                                }
                            }
                            
                            // If pixel has few black neighbors, consider removing it (smoothing)
                            if (blackNeighbors <= 2) {
                                result[i] = result[i + 1] = result[i + 2] = 255; // Make it white
                            }
                        } else if (tempData[i] === 255 && tempData[i + 1] === 255 && tempData[i + 2] === 255) {
                            // For white pixels, check if they should become black (fill small gaps)
                            let blackNeighbors = 0;
                            
                            for (let ky = -1; ky <= 1; ky++) {
                                for (let kx = -1; kx <= 1; kx++) {
                                    if (kx === 0 && ky === 0) continue; // Skip center pixel
                                    
                                    const px = x + kx;
                                    const py = y + ky;
                                    
                                    if (px >= 0 && px < width && py >= 0 && py < height) {
                                        const ni = (py * width + px) * 4;
                                        
                                        if (tempData[ni] === 0 && tempData[ni + 1] === 0 && tempData[ni + 2] === 0) {
                                            blackNeighbors++;
                                        }
                                    }
                                }
                            }
                            
                            // If surrounded by many black pixels, fill the gap
                            if (blackNeighbors >= 6) {
                                result[i] = result[i + 1] = result[i + 2] = 0; // Make it black
                            }
                        }
                    }
                }
            }
            
            return result;
        }
        
        // Download the processed image
        downloadBtn.addEventListener('click', () => {
            const quality = parseInt(outputQuality.value) / 100;
            const format = outputFormat.value;
            const mimeType = format === 'png' ? 'image/png' : 'image/jpeg';
            const dataUrl = resultCanvas.toDataURL(mimeType, quality);
            
            const link = document.createElement('a');
            link.download = `line-drawing.${format}`;
            link.href = dataUrl;
            link.click();
        });
        
        // Helper function to format file size
        function formatFileSize(bytes) {
            if (bytes < 1024) {
                return bytes + ' bytes';
            } else if (bytes < 1024 * 1024) {
                return (bytes / 1024).toFixed(1) + ' KB';
            } else {
                return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
            }
        }
        
        // Estimate JPEG file size from data URL
        function estimateJpegSize(dataUrl) {
            // Remove the data URL prefix to get the base64 string
            const base64 = dataUrl.split(',')[1];
            // Calculate approximate size (base64 is ~33% larger than binary)
            return Math.round(base64.length * 0.75);
        }
        
        // Set initial preset
        presetRecognizable.click();
    </script>
</body>
</html>